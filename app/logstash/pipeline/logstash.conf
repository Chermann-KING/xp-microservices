# Logstash Pipeline Configuration
# Module 6 - Leçon 6.5 : Logging & Monitoring avec ELK

input {
  # Logs depuis TCP (JSON)
  tcp {
    port => 5000
    codec => json
    type => "microservice"
  }

  # Logs depuis UDP (JSON)
  udp {
    port => 5000
    codec => json
    type => "microservice"
  }

  # Logs Docker (via Filebeat - optionnel)
  # beats {
  #   port => 5044
  # }
}

filter {
  # Parser les logs JSON
  if [type] == "microservice" {
    # Ajouter timestamp si manquant
    if ![timestamp] {
      mutate {
        add_field => { "timestamp" => "%{@timestamp}" }
      }
    }

    # Extraire le niveau de log
    if [level] {
      mutate {
        add_field => { "log_level" => "%{level}" }
      }
    } else {
      mutate {
        add_field => { "log_level" => "info" }
      }
    }

    # Ajouter des tags selon le service
    if [service] =~ /auth/ {
      mutate {
        add_tag => ["authentication", "backend"]
      }
    } else if [service] =~ /payment/ {
      mutate {
        add_tag => ["payment", "critical", "backend"]
      }
    } else if [service] =~ /booking/ {
      mutate {
        add_tag => ["booking", "backend"]
      }
    } else if [service] =~ /tour/ {
      mutate {
        add_tag => ["tour", "catalog", "backend"]
      }
    } else if [service] =~ /notification/ {
      mutate {
        add_tag => ["notification", "messaging", "backend"]
      }
    } else if [service] =~ /websocket/ {
      mutate {
        add_tag => ["websocket", "realtime", "backend"]
      }
    } else if [service] =~ /api-gateway/ {
      mutate {
        add_tag => ["gateway", "frontend", "entry-point"]
      }
    }

    # Parser les erreurs
    if [log_level] == "error" or [log_level] == "fatal" {
      mutate {
        add_tag => ["error"]
      }
    }

    # Parser les métriques de performance
    if [duration] {
      mutate {
        convert => { "duration" => "integer" }
        add_tag => ["performance"]
      }
    }

    # Parser les requêtes HTTP
    if [method] and [path] {
      mutate {
        add_tag => ["http-request"]
      }
    }

    # Parser les événements RabbitMQ
    if [event] and [routingKey] {
      mutate {
        add_tag => ["rabbitmq-event"]
      }
    }
  }

  # Géolocalisation IP (optionnel)
  # if [clientIp] {
  #   geoip {
  #     source => "clientIp"
  #   }
  # }
}

output {
  # Sortie vers Elasticsearch
  elasticsearch {
    hosts => ["http://elasticsearch:9200"]
    index => "microservices-logs-%{+YYYY.MM.dd}"
    document_type => "_doc"
  }

  # Sortie console pour debug (désactiver en production)
  stdout {
    codec => rubydebug
  }
}
